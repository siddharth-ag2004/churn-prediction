import os
import datetime
import google.generativeai as genai
from newsapi import NewsApiClient
from dotenv import load_dotenv

def fetch_news(api_key, start_date, end_date, keywords):
    """
    Fetches news articles from NewsAPI for a given date range and keywords.

    Args:
        api_key (str): Your NewsAPI API key.
        start_date (str): The start date in 'YYYY-MM-DD' format.
        end_date (str): The end date in 'YYYY-MM-DD' format.
        keywords (list): A list of keywords to search for.

    Returns:
        str: A single string containing the concatenated content of all found articles,
             or None if no articles are found.
    """
    print(f"Fetching news from {start_date} to {end_date}...")
    newsapi = NewsApiClient(api_key=api_key)
    all_articles_content = []

    # The free NewsAPI plan is limited, but this structure shows how you'd
    # query for multiple topics.
    for keyword in keywords:
        print(f"  - Searching for keyword: '{keyword}'")
        try:
            all_articles = newsapi.get_everything(
                q=keyword,
                from_param=start_date,
                to=end_date,
                language='en',
                sort_by='relevancy',
                page_size=20 # Get up to 20 articles per keyword to stay within limits
            )

            for article in all_articles['articles']:
                title = article.get('title', '')
                content = article.get('description', '') # Use description for concise content
                if content: # Only include articles that have content
                    full_text = f"Title: {title}. Content: {content}\n"
                    all_articles_content.append(full_text)
        
        except Exception as e:
            print(f"    An error occurred while fetching news for '{keyword}': {e}")
            print("    NOTE: The free NewsAPI plan only allows searching dates within the last 30 days.")
            print("    This error is expected if your date range is older. The pipeline logic is still valid.")


    if not all_articles_content:
        return None

    print(f"\nFound a total of {len(all_articles_content)} relevant article snippets.")
    return "\n--- ARTICLE SEPARATOR ---\n".join(all_articles_content)


def analyze_with_gemini(api_key, news_context, start_date, end_date):
    """
    Analyzes the provided news context using the Gemini API to identify churn trends.

    Args:
        api_key (str): Your Gemini API key.
        news_context (str): A string containing all the news article content.
        start_date (str): The start date of the analysis period.
        end_date (str): The end date of the analysis period.

    Returns:
        str: The analytical report generated by Gemini.
    """
    print("Sending news context to Gemini for analysis...")
    
    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel('gemini-2.5-pro')

        prompt = f"""
        **Role:** You are an expert economic and insurance industry analyst.

        **Task:** I have provided a collection of news article headlines and descriptions from the period of {start_date} to {end_date}.
        Your task is to synthesize this information and generate a concise, professional report explaining the major trends and external factors that would likely cause an increase in auto insurance customer churn during this specific period.

        **Instructions:**
        1.  Identify 3-4 primary themes from the news content (e.g., Inflation, Supply Chain Issues, Competitor Actions, etc.).
        2.  For each theme, provide a clear title and a one-paragraph explanation of how it would pressure a typical consumer to reconsider their auto insurance policy.
        3.  Base your analysis strictly on the provided news context below.
        4.  The final output should be a well-structured report suitable for a business presentation.

        **News Context:**
        ---
        {news_context}
        ---
        """

        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        return f"An error occurred while communicating with the Gemini API: {e}"


def main():
    """Main function to run the churn analysis pipeline."""
    # Load API keys from .env file
    load_dotenv()
    news_api_key = os.getenv("NEWS_API_KEY")
    gemini_api_key = os.getenv("GEMINI_API_KEY")

    if not news_api_key or not gemini_api_key:
        print("ERROR: API keys not found. Please create a .env file with your NEWS_API_KEY and GEMINI_API_KEY.")
        return

    # --- CONFIGURATION ---
    # NOTE: Free NewsAPI plan is limited to the last 30 days.
    # For the Dec 2021 - Nov 2022 period, this will not return data on a free plan,
    # but the code demonstrates the full process you'd use with a developer/paid plan.
    # To test, you can use a recent 30-day period.
    
    # Historical Period (Requires paid NewsAPI plan)
    # START_DATE = "2022-05-01"
    # END_DATE = "2022-05-31"
    
    # Test Period (Works on free NewsAPI plan - last 30 days)
    today = datetime.date.today()
    thirty_days_ago = today - datetime.timedelta(days=29)
    START_DATE = thirty_days_ago.strftime("%Y-%m-%d")
    END_DATE = today.strftime("%Y-%m-%d")


    KEYWORDS = [
        "auto insurance rates",
        "car repair costs",
        "inflation CPI",
        "gas prices",
        "used car prices",
        "supply chain automotive"
    ]

    print("="*70)
    print("Starting News-Driven Churn Analysis Pipeline")
    print("="*70)

    # Phase 1: Fetch News
    news_articles_text = fetch_news(news_api_key, START_DATE, END_DATE, KEYWORDS)

    if not news_articles_text:
        print("\nCould not retrieve news articles for the specified period. Exiting.")
        return

    # Phase 2: Analyze with Gemini
    analysis_report = analyze_with_gemini(gemini_api_key, news_articles_text, START_DATE, END_DATE)

    # Phase 3: Display Report
    print("\n\n" + "="*70)
    print("Churn Analysis Report Generated by Gemini")
    print("="*70)
    print(analysis_report)
    print("="*70)


if __name__ == "__main__":
    main()